ニックネームかぶることによるバリデーション(もし重複したくなければ)
会員登録のときrails側のルールを知ってフロントに合わせることにより正確なバリデーションを行う
（今だとなんでも被るユーザーと知らせてる）


商品機能
０．カテゴリー
１．価格
２．入札　ー　ユーザー、メッセージ
３．チャート
４．期限
５．写真

account/profile.tsx + pages/account/にapiで情報入れる

メッセージ機能
























デプロイ時にrails側のサーバー閉ざされたり問題ある時にreact側も５００などにするべき








----------------
設計まとめ
本アプリケーションでは、Next.js（Pages Router）と Rails API（Devise + DeviseTokenAuth）を用いた構成において、
セキュリティ・UX・実務での運用性を重視した認証設計を行いました

- ログイン関連
ユーザー認証についての設計にあたり次の要素を考慮しました
１．ローカルストレージは保安上の理由で実務での使用率が低いためcookieの中にトークンを入れる方式を採用しました
２．ログイン成功時に３つの情報をcookieに保存し,フロントでは Cookie(acess-token,client,uid) の有無のみを軽量なガードとして
使用し、 正当性の検証は Rails 側で必ず行いました. 存在しないユーザーは素早くそのページから弾く形にしました.
方法としてはnext middlewareを使い権限が必要なページを分け、cookieを持ってないユーザ-を弾くようにします.
３．弾かれたユーザーはもちろんユーザー情報が必要なページなどにアクセスできなく正しくログインしてトークンを得る必要があります
４．またrailsのコントローラーにbefore_action: authenticate_user!を用いることにより、
もし仮に悪意を持ったりしてブラウザのcookieが改ざんされた場合を備えてフロントだけじゃなくrailsサーバーでも検証チェックを
するようにしました.
5. さらに保安強化策としてnext.jsのAPI Routesを経由することにしました。
フロントエンドではnext apiをfetchで呼び出しnext apiの中ではaxiosをつかってrailsと
通信することによりバックエンドのapiエンドポイントをユーザーからはわからなくするようにしました.
6．１－5 によってユーザーはより速いuxを感じることも可能になり、フロントおよびサーバーで正しくないトークンを持ったユーザーが
ユーザー情報が入ったapiを呼び出すことができなくなり保安上のトラブルも減する設計になります







!!!nextapiで401などのエラ番号の他にもjsonを返すところは
フロントでfetchのあとthen にresとして出力しないと意味がない！！！

### ニックネーム自動生成の設計意図

ユーザー作成時に nickname が未指定の場合、
`before_create` コールバックで一意な値を生成しています。

DeviseTokenAuth ではユーザー作成時に
内部的に複数回 validation / save が行われるため、
`before_validation` を使用すると
同一レコードに対して nickname が再生成され、
unique index と衝突する可能性があります。

そのため、本アプリでは
**DB INSERT 直前に1度だけ実行される `before_create` を採用**
しています。



READMEの黄金構成（覚えて）

なにを作ったか（1〜2行）

技術スタック

設計方針（← 今あなたが書いてるところ）

工夫した点

実務で意識した点

今後の改善点